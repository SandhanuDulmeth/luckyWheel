<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>8-Segment Controlled Spinning Wheel (Perfect Accuracy)</title>
<style>
  :root { --size: 360px; }
  body { 
    height:100vh; 
    display:flex; 
    align-items:center; 
    justify-content:center; 
    flex-direction:column; 
    gap:18px; 
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    font-family:system-ui,Segoe UI,Roboto,Arial; 
    color: white;
  }
  .page {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 18px;
    width: 100%;
  }
  .wheel-wrap { 
    position: relative; 
    width: var(--size); 
    height: var(--size); 
  }
  .wheel { 
    width:100%; 
    height:100%; 
    border-radius:50%; 
    border:8px solid #fff; 
    box-shadow:0 15px 35px rgba(0,0,0,0.3), 0 5px 15px rgba(0,0,0,0.2); 
    transform:rotate(0deg);
    transition: none;
  }
  .pointer { 
    position:absolute; 
    left:50%; 
    top:-25px; 
    transform:translateX(-50%); 
    width:0; 
    height:0; 
    border-left:20px solid transparent; 
    border-right:20px solid transparent; 
    border-bottom:40px solid #fff; 
    z-index:20;
    filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
  }
  .center { 
    position:absolute; 
    width:80px; 
    height:80px; 
    border-radius:50%; 
    background: linear-gradient(45deg, #fff, #f0f0f0); 
    top:calc(50% - 40px); 
    left:calc(50% - 40px); 
    display:flex; 
    align-items:center; 
    justify-content:center; 
    font-weight:700; 
    border:6px solid #fff; 
    z-index:15;
    color: #333;
    font-size: 14px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
  }
  .controls { 
    display:flex; 
    gap:10px; 
    flex-wrap:wrap; 
    justify-content:center; 
    max-width: 600px;
  }
  button { 
    padding:10px 16px; 
    border-radius:8px; 
    border:2px solid rgba(255,255,255,0.3); 
    background: rgba(255,255,255,0.1);
    backdrop-filter: blur(10px);
    cursor:pointer; 
    color: white;
    font-weight: 600;
    transition: all 0.2s ease;
  }
  button:hover:not(:disabled) {
    background: rgba(255,255,255,0.2);
    border-color: rgba(255,255,255,0.5);
    transform: translateY(-2px);
  }
  button:disabled { 
    opacity:.5; 
    cursor:default; 
    transform: none;
  }
  #message { 
    color:#fff; 
    font-size: 18px;
    font-weight: 600;
    text-align: center;
    min-height: 25px;
    text-shadow: 0 2px 4px rgba(0,0,0,0.3);
  }
  .segment-labels {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    pointer-events: none;
    z-index: 10;
    transition: none;
  }
  .segment-label {
    position: absolute;
    color: white;
    font-weight: bold;
    font-size: 14px;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
    transform-origin: center;
  }
  .debug {
    position: fixed;
    top: 10px;
    left: 10px;
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 10px;
    border-radius: 5px;
    font-family: monospace;
    font-size: 12px;
    z-index: 100;
    display: none;
  }
  table {
    border-collapse: collapse;
    margin: 20px 0;
  }
  th, td {
    border: 1px solid rgba(255,255,255,0.5);
    padding: 8px;
    text-align: center;
  }
  input[type="text"] {
    background: rgba(255,255,255,0.1);
    color: white;
    border: 1px solid rgba(255,255,255,0.3);
    padding: 4px;
    border-radius: 4px;
  }
  h2 {
    margin: 10px 0;
  }
</style>
</head>
<body>

<div id="page1" class="page">
  <div class="wheel-wrap">
    <div class="pointer" aria-hidden="true"></div>
    <div id="wheel" class="wheel" role="img" aria-label="Prize wheel"></div>
    <div class="segment-labels" id="segmentLabels"></div>
    <div class="center" id="centerLabel">SPIN</div>
  </div>
  <div class="controls">
    <button id="startBtn">Start</button>
    <button id="goToTableBtn">Go to Fruit Table</button>
  </div>
  <div id="message">Select a fruit from the Fruit Table and click Start!</div>
</div>

<div id="page2" class="page" style="display:none;">
  <h2>Fruit Table</h2>
  <table id="fruitTable">
    <thead>
      <tr>
        <th>Select</th>
        <th>Fruit Name</th>
      </tr>
    </thead>
    <tbody>
    </tbody>
  </table>
  <button id="goToWheelBtn">Go to Spin Wheel</button>
</div>

<div id="debug" class="debug"></div>

<script>
// === CONFIG ===
const colors = ['#e63946','#f77f00','#ffbe0b','#8ac926','#2ec4b6','#4361ee','#9d4edd','#ff6fbf'];
let names  = ['Strawberry','Orange','Banana','Lime','Blueberry','Plum','Raspberry','Watermelon'];
const segments = colors.length;
const segmentAngle = 360 / segments; // 45 degrees per segment

// Build the wheel - each segment starts at index * 45 degrees
// Segment 0 (Red): 0¬∞ to 45¬∞, Segment 1 (Orange): 45¬∞ to 90¬∞, etc.
const stops = [];
for (let i = 0; i < segments; i++){
  const start = i * segmentAngle;
  const end = start + segmentAngle;
  stops.push(`${colors[i]} ${start}deg ${end}deg`);
}

const wheel = document.getElementById('wheel');
wheel.style.background = `conic-gradient(from 0deg, ${stops.join(', ')})`;

// Add segment labels
const segmentLabels = document.getElementById('segmentLabels');
function updateSegmentLabels() {
  segmentLabels.innerHTML = '';
  for (let i = 0; i < segments; i++) {
    const label = document.createElement('div');
    label.className = 'segment-label';
    label.textContent = names[i];
    
    // Position label at the center of each segment
    const centerAngle = i * segmentAngle + segmentAngle / 2;
    const angleRad = (centerAngle - 90) * Math.PI / 180; // -90 to start from top
    const radius = 120;
    const x = Math.cos(angleRad) * radius + 180;
    const y = Math.sin(angleRad) * radius + 180;
    
    label.style.left = x + 'px';
    label.style.top = y + 'px';
    label.style.transform = 'translate(-50%, -50%)';
    
    segmentLabels.appendChild(label);
  }
}
updateSegmentLabels();

const page1 = document.getElementById('page1');
const page2 = document.getElementById('page2');
const startBtn = document.getElementById('startBtn');
const goToTableBtn = document.getElementById('goToTableBtn');
const goToWheelBtn = document.getElementById('goToWheelBtn');
const fruitTableBody = document.querySelector('#fruitTable tbody');
const message = document.getElementById('message');
const centerLabel = document.getElementById('centerLabel');
const debugDiv = document.getElementById('debug');
let currentRotation = 0;
let spinning = false;
let selectedIndex = -1;

function showPage(p) {
  page1.style.display = p === 1 ? 'flex' : 'none';
  page2.style.display = p === 2 ? 'flex' : 'none';
}

goToTableBtn.addEventListener('click', () => showPage(2));
goToWheelBtn.addEventListener('click', () => showPage(1));

// Build fruit table
for (let i = 0; i < segments; i++) {
  const tr = document.createElement('tr');
  const tdSelect = document.createElement('td');
  const radio = document.createElement('input');
  radio.type = 'radio';
  radio.name = 'selectFruit';
  radio.value = i;
  radio.addEventListener('change', () => {
    selectedIndex = parseInt(radio.value);
  });
  tdSelect.appendChild(radio);
  const tdName = document.createElement('td');
  const input = document.createElement('input');
  input.type = 'text';
  input.value = names[i];
  input.addEventListener('input', () => {
    names[i] = input.value;
    updateSegmentLabels();
  });
  tdName.appendChild(input);
  tr.appendChild(tdSelect);
  tr.appendChild(tdName);
  fruitTableBody.appendChild(tr);
}

// Add debug toggle
document.addEventListener('keydown', (e) => {
  if (e.key === 'd') {
    debugDiv.style.display = debugDiv.style.display === 'none' ? 'block' : 'none';
  }
});

function easeOutCubic(t){ 
  return 1 - Math.pow(1 - t, 3); 
}

function disableControls(disabled){
  startBtn.disabled = disabled;
  goToTableBtn.disabled = disabled;
}

// Get which segment the pointer is currently pointing at
function getCurrentSegment() {
  // Normalize current rotation to 0-360
  const normalizedRotation = ((currentRotation % 360) + 360) % 360;
  
  // After rotating the wheel by normalizedRotation degrees clockwise,
  // we want to know which segment is now at the pointer (0¬∞ position)
  
  const target = (360 - normalizedRotation + 360) % 360;
  const segmentAtPointer = Math.floor(target / segmentAngle) % segments;
  
  return segmentAtPointer;
}

function updateDebug() {
  const current = getCurrentSegment();
  const normalizedRotation = ((currentRotation % 360) + 360) % 360;
  debugDiv.innerHTML = `
    Current Rotation: ${currentRotation.toFixed(1)}¬∞ (${normalizedRotation.toFixed(1)}¬∞)
    Current Segment: ${current} (${names[current]})
    Segment Angle: ${segmentAngle}¬∞
  `;
}

function spinToIndex(targetIndex){
  if (spinning) return;
  
  spinning = true;
  disableControls(true);
  message.textContent = 'Spinning...';
  centerLabel.textContent = '...';

  // PRECISE APPROACH: Calculate exact rotation to align target segment center with pointer
  
  // Target segment center position (in degrees from 0)
  const targetCenter = targetIndex * segmentAngle + (segmentAngle / 2);
  
  // Desired final rotation mod 360
  const desiredRotation = (360 - targetCenter) % 360;
  
  // Current mod
  const currentMod = ((currentRotation % 360) + 360) % 360;
  
  // Rotation needed to reach desired from current
  let rotationNeeded = (desiredRotation - currentMod + 360) % 360;
  
  // Add extra spins for visual effect
  const extraSpins = 3 + Math.floor(Math.random() * 3);
  const totalRotation = rotationNeeded + (extraSpins * 360);
  
  const finalRotation = currentRotation + totalRotation;
  
  console.log(`üéØ Target: ${names[targetIndex]} (index ${targetIndex})`);
  console.log(`üìê Target center: ${targetCenter}¬∞`);
  console.log(`üîÑ Rotation: ${rotationNeeded}¬∞ + ${extraSpins * 360}¬∞ = ${totalRotation}¬∞`);
  console.log(`üìç Final rotation: ${finalRotation}¬∞ (mod 360 = ${((finalRotation % 360) + 360) % 360}¬∞)`);
  
  // Animate to target
  animateRotation(currentRotation, finalRotation, 3500).then(() => {
    currentRotation = finalRotation;
    
    // Verify result with precise calculation
    const normalizedRotation = ((currentRotation % 360) + 360) % 360;
    const landedSegment = getCurrentSegment();
    
    spinning = false;
    disableControls(false);
    centerLabel.textContent = names[landedSegment];
    message.textContent = `üéâ Landed on: ${names[landedSegment]}!`;
    
    updateDebug();
    
    // Detailed verification
    console.log(`üîç Verification:`);
    console.log(`   Final rotation: ${normalizedRotation}¬∞`);
    console.log(`   Expected target center at 0¬∞: ${targetCenter}¬∞ -> should be at ${(targetCenter + normalizedRotation) % 360}¬∞`);
    console.log(`   Landed segment: ${landedSegment} (${names[landedSegment]})`);
    
    if (landedSegment !== targetIndex) {
      console.warn(`‚ùå MISMATCH! Expected ${names[targetIndex]} (${targetIndex}), got ${names[landedSegment]} (${landedSegment})`);
      
      // Calculate where target center actually ended up
      const actualCenterPosition = (targetCenter + normalizedRotation) % 360;
      console.log(`‚ùå Target center ended up at ${actualCenterPosition}¬∞ instead of 0¬∞`);
    } else {
      console.log(`‚úÖ SUCCESS! Perfect landing on ${names[landedSegment]}`);
    }
  });
}

startBtn.addEventListener('click', () => {
  if (selectedIndex === -1) {
    message.textContent = 'Please select a fruit from the table first!';
    return;
  }
  spinToIndex(selectedIndex);
});

function animateRotation(startRotation, endRotation, duration = 3500) {
  return new Promise((resolve) => {
    const startTime = performance.now();
    const rotationDelta = endRotation - startRotation;
    
    function animate(currentTime) {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);
      const easedProgress = easeOutCubic(progress);
      
      const currentRot = startRotation + (rotationDelta * easedProgress);
      wheel.style.transform = `rotate(${currentRot}deg)`;
      segmentLabels.style.transform = `rotate(${currentRot}deg)`;
      
      // Update current rotation for real-time calculation
      currentRotation = currentRot;
      updateDebug();
      
      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        currentRotation = endRotation; // Ensure exact final value
        wheel.style.transform = `rotate(${endRotation}deg)`;
        segmentLabels.style.transform = `rotate(${endRotation}deg)`;
        resolve();
      }
    }
    
    requestAnimationFrame(animate);
  });
}

// Initialize
updateDebug();

// Expose for testing
window.spinToIndex = spinToIndex;
window.getCurrentSegment = getCurrentSegment;
window.testAccuracy = function(iterations = 10) {
  console.log(`üß™ Testing accuracy with ${iterations} iterations...`);
  
  // Reset to clean state
  currentRotation = 0;
  wheel.style.transform = 'rotate(0deg)';
  segmentLabels.style.transform = 'rotate(0deg)';
  
  let correct = 0;
  
  for (let i = 0; i < iterations; i++) {
    const targetIndex = Math.floor(Math.random() * segments);
    const targetName = names[targetIndex];
    const targetCenter = targetIndex * segmentAngle + (segmentAngle / 2);
    
    console.log(`\n--- Test ${i+1}: ${targetName} (index ${targetIndex}) ---`);
    console.log(`Target center: ${targetCenter}¬∞`);
    
    // Use exact same calculation as spinToIndex
    const desiredRotation = (360 - targetCenter) % 360;
    const currentMod = ((currentRotation % 360) + 360) % 360;
    let rotationNeeded = (desiredRotation - currentMod + 360) % 360;
    const extraSpins = 4; // Fixed for testing
    const totalRotation = rotationNeeded + (extraSpins * 360);
    const finalRotation = currentRotation + totalRotation;
    
    console.log(`Rotation: ${rotationNeeded}¬∞ + ${extraSpins * 360}¬∞ = ${totalRotation}¬∞`);
    console.log(`Final absolute: ${finalRotation}¬∞`);
    
    // Update rotation and test
    currentRotation = finalRotation;
    const normalizedRotation = ((currentRotation % 360) + 360) % 360;
    console.log(`Normalized: ${normalizedRotation}¬∞`);
    
    // Verify where target center ended up
    const actualCenterPos = (targetCenter + normalizedRotation) % 360;
    console.log(`Target center now at: ${actualCenterPos}¬∞ (should be 0¬∞)`);
    
    const landedSegment = getCurrentSegment();
    console.log(`Landed on: ${names[landedSegment]} (index ${landedSegment})`);
    
    if (landedSegment === targetIndex) {
      correct++;
      console.log(`‚úÖ CORRECT`);
    } else {
      console.log(`‚ùå WRONG`);
      
      // Debug the getCurrentSegment calculation
      const target = (360 - normalizedRotation + 360) % 360;
      console.log(`getCurrentSegment debug: target=${target}¬∞, segment=${Math.floor(target / segmentAngle)}`);
    }
  }
  
  console.log(`\nüìä Result: ${correct}/${iterations} (${(correct/iterations*100).toFixed(1)}%)`);
  
  // Reset
  currentRotation = 0;
  wheel.style.transform = 'rotate(0deg)';
  segmentLabels.style.transform = 'rotate(0deg)';
  updateDebug();
  
  return correct / iterations;
};

console.log('üéØ Spinning Wheel Loaded! Press "d" to toggle debug info');
console.log('üß™ Run testAccuracy() to test the precision');
</script>

</body>
</html>